Please report any errors to Kevin Lin (klsix@princeton.edu) and cc Robert Vanderbei (rvdb@princeton.edu). The code was upgraded to be fully automated (unlike when simulations were originally run), so minor errors might occur.

######
Simplified Instructions:
Within the folder "CTS", within DEMO_CODE (to ensure that the code can run),
run the following commands:

[[PHASE 1. Compiling.]]
Step 1: Open "compile.sh". All the needed commands are stored here. Run the
first 8 "make" lines to compile the C code.

[[PHASE 2. Running Changing Sparsity Code.]]
Step 2: Run the next two lines "sh run_el1*.sh" together.
Step 3: Run the next line "sh run_loqo_el1.sh".
Step 4: Run the next line "sh run_loqo_el1sparse.sh". 
 -- NOTE: It is important to run Step 3 and Step 4 individually, not in the
same command.
Step 5: Run the next 4 matlab lines.

[[PHASE 3. Running Chaning Size Code.]]
Step 6: Run the next two lines "sh run_el1*_size.sh" together.
Step 7: Run the line "sh run_loqo_el1_size.sh".
Step 8: Run the line "sh run_loqo_el1sparse_size.sh".
 -- NOTE: Like before, it is important to run Step 8 and Step 9 individually.
Step 9: Run the next 4 matlab lines.

[[PHASE 4. Creating plots and tables.]]
Step 10: Run the last 5 R commands and 2 matlab lines. You're done afterwards!

After running Steps 2-5, the commented-out line in compile.sh will tell you
what files should have been generated as output.

After running this code in DEMO_CODE, you can run now in simulation_code,
which is the real code for our simulation results. Apply the same 10 steps,
bue Steps 2-9 could takes hours or days.




####################
ADDITIONAL DETAILS BELOW
###################
#INSTALLATION
1) Unzip all_code.zip (if bundled in zip).
2) There are two folders within the zip file. One is simulation_code and the 
other is DEMO_CODE. 
3) Within DEMO_CODE, run "sh compile.sh". 

NOTE: The scripts run in this are NOT representative of the actual simulation. 
They are simply to check that everything on the machine is in working order.
NOTE 2: We have experienced that within compile.sh, sometimes the lines 
"sh run_loqo_el1.sh", "sh run_loqo_el1sparse.sh", "sh run_loqo_el1_size.sh" 
and "sh_run_loqo_el1sparse_size.sh" need to be manually run. 
NOTE 3: The tables are generated in plotter_xtable.R and plotter_xtable_size.R. 
You need to open R manually and run "source("plotter_xtable.R")" to see the 
tables though.
NOTE 4: For only the DEMO_CODE, the plots generated by plotres.m and plotres_size.m 
do not visually contain the blue lines because they are all 0 (effectively complete 
instantly).

4) Once you are satisfied with DEMO_CODE, go to all_code and run "sh compile.sh". 
This runs the full simulation code and can take many days. Notes 2 and 3 still 
apply to simulation_code.

####################
#DATA FILES
The data files are called "rng_gauss.csv" (a file of standard Gaussian numbers) and
"rng_idx.csv" (a file of uniformally distributed integers). These serve as the
files to generate random problems. The sensing matrix is constructed by
starting at a pre-specified trial number and fills in the matrix
entry-by-entry, taking numbers from "rng_gauss.csv". Likewise, the true signal 
vector is constructed by looking at
"rng_idx.csv" and putting a "1" at the specified locations.
This procedure ensures that the same problem, even across different coding
languages, will be solved by the different solvers. 

Both simulation_code and DEMO_CODE share the same rng_gauss.csv and
rng_idx.csv.

######################
#Example Code to Run
All the necessary code to run is located within compile.sh for both
simulation_code and DEMO_CODE. compile.sh is split up into 4 sections.

Section 1) Compiling C code via make files.
Section 2) Running all the solvers for problems with varying sparsity level.
This section runs 7 solvers. They are:
  -- el1: This is our simplex method for standard CS (solver runs in C)
  -- el1sparse: Simplex method for KCS (solver runs in C)
  -- loqo_el1: Interior point method for standard CS (very slow as expected, 
               solver runs in AMPL, calls C code to setup)
  -- loqo_el1sparse: Interior point method for KCS (solver runs in AMPL,
                     calls C code to setup)
  -- fhtp: Fast Hard Thresholding Pursuit for standard CS knowing true sparsity 
           level (runs in matlab)
  -- fhtp_agnostic: FHTP for standard CS not knowing the true sparsity level 
                    (runs in matlab)
  -- l1ls: L1_LS for standard CS (runs in matlab)
  -- MirrorProx: Mirror Prox for standard CS (runs in matlab)

The solvers for fhtp, l1ls, and MirrorProx were developed by other authors and
serve as our benchmarks. The code to call all these solvers are located within
their respective shell file and/or matlab file.

The outputs of these simulations are stored in .csv files. The exact file
names are listed in compile.sh.
Section 3) Running all solvers for problems with varying size. Similar
attributes to Section 2.
Section 4) Processing all results to produce the Latex table and the figure.
"read_ampl.R" formats all the AMPL files (from loqo). "process_loqo.R"
constructs the appropriate .csv file. "plotter_table.R" constructs the Latex
code for the table, and "plotres.m" constructs the figure.
#############################

Thank you! :)

Please ask any questions to Kevin Lin and Robert Vanderbei (emails above). 
