Please report any errors to Kevin Lin (klsix@princeton.edu) and cc Robert Vanderbei (rvdb@princeton.edu). The code was upgraded to be fully automated (unlike when simulations were originally run), so minor errors might occur.

######
Simplified Instructions:
Run the following commands:

[[PHASE 1. Compiling.]]
Step 1: Open "compile.sh". All the needed commands are stored here. Run the
first 8 "make" lines to compile the C code.

[[PHASE 2. Running Changing Sparsity Code.]]
Step 2: Run the next two lines "sh run_el1*.sh" together.
Step 3: Run the next line "sh run_loqo_el1.sh".
Step 4: Run the next line "sh run_loqo_el1sparse.sh". 
 -- NOTE: It is important to run Step 3 and Step 4 individually, not in the
same command.
Step 5: Run the next 4 matlab lines.

[[PHASE 3. Running Chaning Size Code.]]
Step 6: Run the next two lines "sh run_el1*_size.sh" together.
Step 7: Run the line "sh run_loqo_el1_size.sh".
Step 8: Run the line "sh run_loqo_el1sparse_size.sh".
 -- NOTE: Like before, it is important to run Step 8 and Step 9 individually.
Step 9: Run the next 4 matlab lines.

[[PHASE 4. Creating plots and tables.]]
Step 10: Run the last R commands and matlab lines. You're done afterwards!

After running Steps 2-5, the commented-out line in compile.sh will tell you
what files should have been generated as output.

The code could take several days to run.



####################
ADDITIONAL DETAILS BELOW
###################
NOTE 1: We have experienced that within compile.sh, sometimes the lines 
"sh run_loqo_el1.sh", "sh run_loqo_el1sparse.sh", "sh run_loqo_el1_size.sh" 
and "sh_run_loqo_el1sparse_size.sh" need to be manually run. 
NOTE 2: The tables are generated in plotter_xtable.R and plotter_xtable_size.R. 
You need to open R manually and run "source("plotter_xtable.R")" to see the 
tables though.
NOTE 3: For only the DEMO_CODE, the plots generated by plotres.m and plotres_size.m 
do not visually contain the blue lines because they are all 0 (effectively complete 
instantly).


####################
#DATA FILES
The data files are called "rng_gauss.csv" (a file of standard Gaussian numbers) and
"rng_idx.csv" (a file of uniformally distributed integers). These serve as the
files to generate random problems. The sensing matrix is constructed by
starting at a pre-specified trial number and fills in the matrix
entry-by-entry, taking numbers from "rng_gauss.csv". Likewise, the true signal 
vector is constructed by looking at
"rng_idx.csv" and putting a "1" at the specified locations.
This procedure ensures that the same problem, even across different coding
languages, will be solved by the different solvers. 


######################
#Example Code to Run
All the necessary code to run is located within compile.sh. compile.sh is split up into 4 sections.

Section 0) Running "clean.sh" to remove extra files (that could have been residues from past simulations). This WILL remove all your results, so save them to another folder beforehand.
Section 1) Compiling C code via make files.
Section 2) Running all the solvers for problems with varying sparsity level.
This section runs 7 solvers. They are:
  -- el1: This is our simplex method for standard CS (solver runs in C)
  -- el1sparse: Simplex method for KCS (solver runs in C)
  -- loqo_el1: Interior point method for standard CS (very slow as expected, 
               solver runs in AMPL, calls C code to setup)
  -- loqo_el1sparse: Interior point method for KCS (solver runs in AMPL,
                     calls C code to setup)
  -- fhtp: Fast Hard Thresholding Pursuit for standard CS knowing true sparsity 
           level (runs in matlab)
  -- fhtp_agnostic: FHTP for standard CS not knowing the true sparsity level 
                    (runs in matlab)
  -- l1ls: L1_LS for standard CS (runs in matlab)
  -- MirrorProx: Mirror Prox for standard CS (runs in matlab)

The solvers for fhtp, l1ls, and MirrorProx were developed by other authors and
serve as our benchmarks. The code to call all these solvers are located within
their respective shell file and/or matlab file.

The outputs of these simulations are stored in .csv files. The exact file
names are listed in compile.sh.
Section 3) Running all solvers for problems with varying size. Similar
attributes to Section 2.
Section 4) Processing all results to produce the Latex table and the figure.
"read_ampl.R" formats all the AMPL files (from loqo). "process_loqo.R"
constructs the appropriate .csv file. "rmUnbounded.R" checks that there are no unbounded instances in the problem, sometimes occuring in our C implementation. "plotter_table.R" constructs the Latex
code for the table, and "plotres.m" constructs the figure.
#############################

Thank you! :)

Please ask any questions to Kevin Lin and Robert Vanderbei (emails above). 
